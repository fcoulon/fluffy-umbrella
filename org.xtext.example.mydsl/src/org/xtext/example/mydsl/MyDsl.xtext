grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"


/*****************
 * AQL++ grammar *
 *****************/

rRoot :
	'behavior' behaviour=Qualified 
	syntaxes+=rImportSyntax*
	semantics+=rImportSemantic*
	services+=rImportService*
	xtendedClasses+=rClass*
;

Qualified: ID ('.'ID)*;

rImportSyntax returns ImportSyntax: 
	{ImportSyntax}
	'import' 'syntax' uri=STRING 'as' name=ID ';'
;

rImportSemantic : 'import' 'semantic' Qualified 'as' ID '(' ID '=>' ID ')' ';'
;

rImportService : 'import' 'service' Qualified ';'
;

rClass : 'class' (syntax=[ImportSyntax])'.'name=ID '{' attributes+=rAttribute* operations+=rOperation* '}'
; 

rOperation : rTag* ('def' | 'override') type=ID name=ID '(' paramList+=rParameters? ')' body=rBlock
;

rTag : '@'ID
;

rParameters : params+=rVariable (',' params+=rVariable)*
;

rVariable : type=ID name=ID
;

rAttribute : type=ID name=ID (':=' expression)? ';'
;

rStatement : rVarDecl 
		| rAssign
		| rForEach
		| rWhile
		| rIf
		| rExpression
;

rVarDecl : ID ID (':=' expression)? ';'
;

rAssign : expression ':=' expression ';'
;

rForEach : 'for' '(' ID  'in' rCollection ')' rBlock
;

rCollection : '[' INT '..' INT ']' | expression
;

rBlock : '{' (rStatement (rStatement)*)? '}'
;

rIf : 'if' '(' expression ')' rBlock ('else' rBlock)?
;

rWhile : 'while' '(' expression ')' rBlock
;

rExpression : expression ';'
;

/***************
 * AQL grammar *
 ***************/

expression :
	nonLeftRecExpression recExpression?
;

recExpression :
	(navigationSegment | MultOp expression | addOp expression | compOp expression | 'and' expression | 'or' expression | 'xor' expression | 'implies' expression) recExpression?
;

navigationSegment :     '.'ID
				      | '.' callExp
				      | '->' callExp
;    

nonLeftRecExpression :
              'not' expression
		     | '-' expression
		     | ID
		     | literal
		     | '(' expression ')'
		     | 'if' expression 'then' expression 'else' expression 'endif'
		     | 'let' binding (',' binding)* 'in' expression
;

binding : ID (':' typeLiteral)? '=' expression
;

addOp: '+' | '-'
;

compOp :     '<='
	    	|'>='
	  		|'!='
	  		|'<>'
	  		|'='
	  		|'=='
	 		|'<'
	  		|'>'
;


callExp :     collectionIterator '(' variableDefinition lambdaExpression ')'
			| ID'(' expressionSequence ')'
;

lambdaExpression : expression
;

collectionIterator : 'select' | 'reject' | 'collect' | 'any' | 'exists' | 'forAll' | 'isUnique' | 'one' | 'sortedBy' | 'closure'
;

expressionSequence : (expression (',' expression)*)?
;

variableDefinition : ID (':' typeLiteral)? '|'
;

literal :    STRING
		   | INT
		   | Real
		   |'true'
		   |'false'
		   |'null'
		   |'Sequence{' expressionSequence '}'
		   |'OrderedSet{' expressionSequence '}'
		   | ID '::' ID '::' ID
		   | ID '::' ID ':'
		   | typeLiteral
;

typeLiteral :   'String'
		      | 'Integer'
		      | 'Real'
		      | 'Boolean'
		      | 'Sequence(' typeLiteral')'
		      | 'OrderedSet(' typeLiteral')'
		      | classifierTypeRule
		      | '{' classifierTypeRule ('|' classifierTypeRule)* '}'
;

classifierTypeRule :   ID '::' ID
				     | ID ':' 
;

terminal MultOp : '*' | '/'
;

terminal Real : INT'.'INT
;